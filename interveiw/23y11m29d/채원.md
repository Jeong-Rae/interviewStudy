## 23/11/29 Interview Study - 김채원

### 질문 목록

1. StyledComponent를 이용해서 css를 적용한 이유

   > StyledComponent를 사용하여 관리할 경우 한 페이지에서 적용되는 css를 관리할 수 있다. 따라서 적용되는 범위에 따라 css를 확인할 수 있어 관리가 용이할 것이라 생각함. 하지만 폴더 별로 페이지와 css를 관리하는 방식도 좋을 것 같음.

2. 동의서 정보를 저장할 때 동의서 양식에 대한 테이블을 따로 처리하지 않고 JSON 형식으로 저장한 이유
   > 개발 시간이 여유롭지 않아 프론트에서 어떤 형식으로 동의서 양식을 전달할 지 정하지 않아 개발의 편의를 위해 json 형식으로 전달받아 관리함.

> <토론 시간>
>
> 1. JSON 형식을 저장하는 방식은 지양해야 할까?
>
> JSON 형태로 넣을 경우 유효성 체크와 검색 등의 쿼리를 짜지 못하는 단점이 있지만 따로 데이터에 대한 관리 로직이 필요 없을 경우 불필요하게 컬럼을 늘리지 않아도 되고 select 했을 떄 하나의 컬럼만 가져오면 되므로 DB의 부담이 적다. 또한 동의서 양식에 포함되는 컬럼이 늘어나도 대처할 필요 없다.
>
> 2. JSON 형태의 데이터를 다룰 때는 Postgresql을 쓰자
>
> PostgreSQL은 JSON 데이터를 저장하고 쿼리하기 위한 여러 기능을 제공한다. JSON 데이터 타입이 있고, JSONB라는 이진 형식의 JSON 데이터를 더 효율적으로 저장하는 형식도 제공된다. 이를 사용하면 JSON 데이터를 삽입하고 쿼리할 때 더 편리하게 작업할 수 있다. 예를 들어, JSONB 형식은 인덱싱이 가능하므로 쿼리의 성능이 향상되고, JSON 데이터를 특정 필드에 저장하고 필요한 경우에만 해당 데이터를 쿼리할 수 있다.

3. API 명세를 작성할 때 postman을 사용하던데 이유가 있는지
   > 개발하면서 테스트하고 바로 제공할 수 있어 사용함.

> <토론 시간>
>
> 1. (꿀팁) swagger yml 파일을 postman에 업로드하면 그대로 적용된다..! ㄷㄷ
> 2. RestDocs
>
> - 테스트 코드 기반으로 Restful API 문서 생성을 돕는 도구
> - Asciidoctor를 이용해서 HTML 등 다양한 포맷으로 문서를 자동을 출력할 수 있다.
> - 테스트 코드 기반으로 문서를 작성하기 때문에 검증된 문서를 보장한다.

4. ORM에 대해 설명해주세요.
   > ORM이란 객체와 관계형 데이터 베이스의 테이블을 매핑해주는 것이다. 연관 관계의 종류는 단방향, 양방향 / 일대일, 다대다, 다대일 등 다양하다.
   >
   > `꼬리질문` "사용한 어노테이션에 대해 자세히 설명 ㄱㄱ"
   >
   > - 양방향 매핑된 객체에 @JsonIgnore를 추가하여 Team과 Member 객체에 대한 관계에서 member 객체를 조회할 때 team 객체를 조회하고 또 다시 member 객체를 조회하게 되는 무한 루프가 발생되는 것을 막는다.
   > - `fetch = Lazy` 속성을 사용하여 지연 로딩 설정이 되어있는 엔티티는 프록시 객체로 가져온다. 후에 해당 엔티티를 실제로 사용하는 시점에 초기화하여 쿼리가 날라간다. 이 속성을 사용해 연관관계가 있는 모든 엔티티를 가져오는 것이 아닌 필요한 엔티티의 정보만을 가져오도록 하였다.

### Subnet

- 왜 필요할까?

  > IPv4로는 모든 PC가 호스트 주소를 할당받을 수 없다. 따라서 네트워크를 분할하여 사용할 필요성이 생김

- 서브넷이란?

  > `서브넷`이란 하나의 네트워크가 분할되어 나눠진 작은 네트워크이다. 네트워크를 분할하는 것을 `서브네팅(Subnettin)`이라 하고 이는 `서브넷 마스크(Submnet Mask)`를 통하여 수행될 수 있다.

- A 라우터의 내 PC가 B 라우터의 다른 PC로 요청을 보내는 과정

> 1. `IP 주소 할당` : 각 라우터와 PC는 고유한 IP 주소를 할당받는다. Public IP를 할당받은 A 라우터의 서브넷에서 내 PC는 해당 IP를 분기한 IP를 할당받는다. B 라우터의 PC 또한 마찬가지.
> 2. `서브넷 마스크 확인` : 각 PC와 라우터는 자신의 IP 주소와 함께 서브넷 마스크를 사용하여 속한 서브넷을 확인하낟. 서브넷 마스크는 IP 주소의 어떤 부분이 네트워크 주소이고 어떤 부분이 호스트 주소인지를 결정한다.
> 3. `라우팅 테이블 확인` : 내 PC는 라우팅 테이블을 참고하여 목적지 IP 주소가 속한 서브넷이 자신의 서브넷인지, 아니면 외부 서브넷인지 확인한다. 라우터는 패킷을 다음 목적지로 전달할 적절한 인터페이스를 결정하기 위해 라우팅 테이블을 사용한다.
>
> - 라우팅 테이블은 각 라우터가 자체적으로 유지하고 사용하는 로컬 데이터 구조로 이를 사용해 해킷이 어떻게 전달되어야 하는지 결정한다.
> - 라우팅 테이블이 포함하는 정보

    - 목적지 네트워크 주소 : 전송하려는 목적지 네트워크의 IP 주소 또는 IP 주소 범위
    - 서브넷 마스크 : 목적지 네트워크의 서브넷 마스크를 이용해 목적지 주소가 속한 서브넷을 식별
    - 게이트웨이 또는 다음 홉 : 목적지에 도달하기 위해 패킷을 보낼 다음 라우터 또는 게이트웨이의 IP 주소. 패킷이 목적지에 직접 연결되어 있으면 게이트웨이가 필요하지 않을 수도 있다.
    - 출발지 인터페이스 : 목적지로 가는 패킷이 나가야 하는 출발지 인터페이스. 라우터에 여러개의 네트워크 인터페이스가 있을 때 어느 인터페이스를 사용해야 하는 지를 결정한다.

> 4. `라우팅` : 내 PC는 B 라우터의 서브넷에 있는 다른 PC로 향하는 패킷을 보내기 위해 A 라우터를 경유한다. A라우터는 패킷을 받아서 목적지 주소를 확인하고, B 라우터를 향해 패킷을 전달한다.
> 5. `목적지 도달` : 패킷은 B 라우터에 도달하고, B 라우터는 자신의 서브넷에서 목적지 PC로 패킷을 전달한다.

- 블랙박스 효과는 유용한가?
  > - 메시지를 보낼 때 외부 라우터에서 봤을 때는 Public IP로 전송하는 것이므로 모두 같은 주소로 보내는 것으로 인식된다.
  > - 서버에게 클라이언트 정보를 제공하지 않기 때문에 보안성 good~
  > - 라우팅마다 cost가 소모되는게 문제 된다고 생각할 수도 있지만 유의미한 정도는 아니다.
  > - 포트마다(?) 컴퓨터를 개별적으로 관리할 수 있기 때문에 이점이 더 크다.
  >   - 네트워크 스위치는 여러 개의 포트를 가지고 있으며, 각 포트는 하나의 물리적인 연결 지점이다. 포트마다 컴퓨터를 연결하여 스위치에서 각 컴퓨터에 대한 관리와 제어가 가능해져 네트워크 트래픽 관리, 보안 기능 강화가 가능하다.
